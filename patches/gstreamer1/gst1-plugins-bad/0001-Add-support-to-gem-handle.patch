From 5004933d6343b337cbcc0bb15cc0056413e5dab7 Mon Sep 17 00:00:00 2001
From: Sandeep Sheriker M <sandeep.sheriker@microchip.com>
Date: Thu, 24 Jan 2019 17:00:09 -0700
Subject: [PATCH] Add support to gem handle

Signed-off-by: Sandeep Sheriker M <sandeep.sheriker@microchip.com>
---
 sys/kms/gstkmsallocator.c | 117 +++++++++++++++++++++++++++++++++++++++-------
 sys/kms/gstkmsallocator.h |   6 ++-
 sys/kms/gstkmssink.c      |  60 +++++++++++++++++++++++-
 sys/kms/gstkmssink.h      |   6 +++
 4 files changed, 168 insertions(+), 21 deletions(-)

diff --git a/sys/kms/gstkmsallocator.c b/sys/kms/gstkmsallocator.c
index 648ac2f..87b8389 100644
--- a/sys/kms/gstkmsallocator.c
+++ b/sys/kms/gstkmsallocator.c
@@ -1,10 +1,12 @@
 /* GStreamer
  *
  * Copyright (C) 2016 Igalia
+ * Copyright (C) Microchip Technology Inc.
  *
  * Authors:
  *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
  *  Javier Martin <javiermartin@by.com.es>
+ *  Sandeep Sheriker M <sandeepsheriker.mallikarjun@microchip.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -39,6 +41,7 @@
 
 #include "gstkmsallocator.h"
 #include "gstkmsutils.h"
+#include "gstkmssink.h"
 
 #define GST_CAT_DEFAULT kmsallocator_debug
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
@@ -103,6 +106,7 @@ gst_kms_allocator_memory_reset (GstKMSAllocator * allocator, GstKMSMemory * mem)
   if (!check_fd (allocator))
     return;
 
+  if (allocator->kmssink->Ismaster) {
   if (mem->fb_id) {
     GST_DEBUG_OBJECT (allocator, "removing fb id %d", mem->fb_id);
     drmModeRmFB (allocator->priv->fd, mem->fb_id);
@@ -128,6 +132,7 @@ gst_kms_allocator_memory_reset (GstKMSAllocator * allocator, GstKMSMemory * mem)
 
   g_free (mem->bo);
   mem->bo = NULL;
+  }
 }
 
 static gboolean
@@ -148,18 +153,23 @@ gst_kms_allocator_memory_create (GstKMSAllocator * allocator,
   if (!kmsmem->bo)
     return FALSE;
 
-  fmt = gst_drm_format_from_video (GST_VIDEO_INFO_FORMAT (vinfo));
-  arg.bpp = gst_drm_bpp_from_drm (fmt);
-  arg.width = GST_VIDEO_INFO_WIDTH (vinfo);
-  arg.height = gst_drm_height_from_drm (fmt, GST_VIDEO_INFO_HEIGHT (vinfo));
+  if (allocator->kmssink->Ismaster) {
+    fmt = gst_drm_format_from_video (GST_VIDEO_INFO_FORMAT (vinfo));
+    arg.bpp = gst_drm_bpp_from_drm (fmt);
+    arg.width = GST_VIDEO_INFO_WIDTH (vinfo);
+    arg.height = gst_drm_height_from_drm (fmt, GST_VIDEO_INFO_HEIGHT (vinfo));
 
-  ret = drmIoctl (allocator->priv->fd, DRM_IOCTL_MODE_CREATE_DUMB, &arg);
-  if (ret)
-    goto create_failed;
+    ret = drmIoctl (allocator->priv->fd, DRM_IOCTL_MODE_CREATE_DUMB, &arg);
+    if (ret)
+      goto create_failed;
 
-  kmsmem->bo->handle = arg.handle;
-  kmsmem->bo->size = arg.size;
-  kmsmem->bo->pitch = arg.pitch;
+    kmsmem->bo->handle = arg.handle;
+    kmsmem->bo->size = arg.size;
+    kmsmem->bo->pitch = arg.pitch;
+  } else {
+    kmsmem->bo->handle = allocator->kmssink->gemhandle;
+    kmsmem->bo->size = allocator->kmssink->gemsize;
+  }
 
   return TRUE;
 
@@ -269,6 +279,7 @@ gst_kms_memory_map (GstMemory * mem, gsize maxsize, GstMapFlags flags)
   int err;
   gpointer out;
   struct drm_mode_map_dumb arg = { 0, };
+  size_t size = 0;
 
   alloc = (GstKMSAllocator *) mem->allocator;
 
@@ -285,6 +296,7 @@ gst_kms_memory_map (GstMemory * mem, gsize maxsize, GstMapFlags flags)
   }
 
   arg.handle = kmsmem->bo->handle;
+  size = kmsmem->bo->size;
 
   err = drmIoctl (alloc->priv->fd, DRM_IOCTL_MODE_MAP_DUMB, &arg);
   if (err) {
@@ -293,13 +305,14 @@ gst_kms_memory_map (GstMemory * mem, gsize maxsize, GstMapFlags flags)
     return NULL;
   }
 
-  out = mmap (0, kmsmem->bo->size,
-      PROT_READ | PROT_WRITE, MAP_SHARED, alloc->priv->fd, arg.offset);
+  out = mmap (0, size, PROT_READ | PROT_WRITE, MAP_SHARED,
+      alloc->priv->fd, arg.offset);
   if (out == MAP_FAILED) {
     GST_ERROR_OBJECT (alloc, "Failed to map dumb buffer object: %s %d",
         strerror (errno), errno);
     return NULL;
   }
+
   kmsmem->bo->ptr = out;
 
 out:
@@ -344,10 +357,14 @@ gst_kms_allocator_init (GstKMSAllocator * allocator)
 }
 
 GstAllocator *
-gst_kms_allocator_new (int fd)
+gst_kms_allocator_new (GstKMSSink * self)
 {
-  return g_object_new (GST_TYPE_KMS_ALLOCATOR, "name",
-      "KMSMemory::allocator", "drm-fd", fd, NULL);
+  GstKMSAllocator *alloc = g_object_new (GST_TYPE_KMS_ALLOCATOR, "name",
+      "KMSMemory::allocator", "drm-fd", self->fd, NULL);
+
+  alloc->kmssink = self;
+
+  return GST_ALLOCATOR_CAST (alloc);
 }
 
 /* The mem_offsets are relative to the GstMemory start, unlike the vinfo->offset
@@ -361,6 +378,8 @@ gst_kms_allocator_add_fb (GstKMSAllocator * alloc, GstKMSMemory * kmsmem,
   guint32 w, h, fmt, pitch = 0, bo_handles[4] = { 0, };
   guint32 offsets[4] = { 0, };
   guint32 pitches[4] = { 0, };
+  struct drm_mode_map_dumb arg = { 0, };
+  gpointer out;
 
   if (kmsmem->fb_id)
     return TRUE;
@@ -398,13 +417,32 @@ gst_kms_allocator_add_fb (GstKMSAllocator * alloc, GstKMSMemory * kmsmem,
         i, pitches[i], offsets[i]);
   }
 
-  ret = drmModeAddFB2 (alloc->priv->fd, w, h, fmt, bo_handles, pitches,
-      offsets, &kmsmem->fb_id, 0);
+  if (alloc->kmssink->Ismaster) {
+    ret = drmModeAddFB2 (alloc->priv->fd, w, h, fmt, bo_handles, pitches,
+        offsets, &kmsmem->fb_id, 0);
+    if (ret) {
+      GST_ERROR_OBJECT (alloc, "Failed to bind to framebuffer: %s (%d)",
+          strerror (-ret), ret);
+      return FALSE;
+    }
+  }
+  arg.handle = kmsmem->bo->handle;
+
+  ret = drmIoctl (alloc->priv->fd, DRM_IOCTL_MODE_MAP_DUMB, &arg);
   if (ret) {
-    GST_ERROR_OBJECT (alloc, "Failed to bind to framebuffer: %s (%d)",
+    GST_ERROR_OBJECT (alloc, "Failed to get offset of buffer object: %s %d",
         strerror (-ret), ret);
     return FALSE;
   }
+
+  out = mmap (0, kmsmem->bo->size,
+      PROT_READ | PROT_WRITE, MAP_SHARED, alloc->priv->fd, arg.offset);
+  if (out == MAP_FAILED) {
+    GST_ERROR_OBJECT (alloc, "Failed to map dumb buffer object: %s %d",
+        strerror (errno), errno);
+    return FALSE;
+  }
+
   return TRUE;
 }
 
@@ -431,6 +469,11 @@ gst_kms_allocator_bo_alloc (GstAllocator * allocator, GstVideoInfo * vinfo)
   GstKMSAllocator *alloc;
   GstKMSMemory *kmsmem;
   GstMemory *mem;
+  GstKMSSink *self;
+  GstVideoRectangle src = { 0, };
+  GstVideoRectangle dst = { 0, };
+  GstVideoRectangle result;
+  gint ret;
 
   mem = gst_kms_allocator_alloc_empty (allocator, vinfo);
   if (!mem)
@@ -438,11 +481,49 @@ gst_kms_allocator_bo_alloc (GstAllocator * allocator, GstVideoInfo * vinfo)
 
   alloc = GST_KMS_ALLOCATOR (allocator);
   kmsmem = (GstKMSMemory *) mem;
+  self = alloc->kmssink;
+
   if (!gst_kms_allocator_memory_create (alloc, kmsmem, vinfo))
     goto fail;
   if (!gst_kms_allocator_add_fb (alloc, kmsmem, vinfo->offset, vinfo))
     goto fail;
 
+  if (self->Ismaster) {
+    src.w = GST_VIDEO_SINK_WIDTH (self);
+    src.h = GST_VIDEO_SINK_HEIGHT (self);
+
+    dst.w = self->hdisplay;
+    dst.h = self->vdisplay;
+
+  retry_set_plane:
+    gst_video_sink_center_rect (src, dst, &result, self->can_scale);
+
+    src.w = GST_VIDEO_INFO_WIDTH (&self->vinfo);
+    src.h = GST_VIDEO_INFO_HEIGHT (&self->vinfo);
+
+    GST_TRACE_OBJECT (alloc,
+        "drmModeSetPlane at (%i,%i) %ix%i sourcing at (%i,%i) %ix%i",
+        result.x, result.y, result.w, result.h, src.x, src.y, src.w, src.h);
+
+    /* source/cropping coordinates are given in Q16 */
+    ret = drmModeSetPlane (self->fd, self->plane_id, self->crtc_id,
+        kmsmem->fb_id, 0, result.x, result.y, result.w, result.h,
+        src.x << 16, src.y << 16, src.w << 16, src.h << 16);
+    if (ret) {
+      if (self->can_scale) {
+        self->can_scale = FALSE;
+        goto retry_set_plane;
+      }
+      GST_DEBUG_OBJECT (alloc, "result = { %d, %d, %d, %d} / "
+          "src = { %d, %d, %d %d } / dst = { %d, %d, %d %d }", result.x,
+          result.y, result.w, result.h, src.x, src.y, src.w, src.h, dst.x,
+          dst.y, dst.w, dst.h);
+      GST_ELEMENT_ERROR (alloc, RESOURCE, FAILED, (NULL),
+          ("drmModeSetPlane failed: %s (%d)", strerror (-ret), ret));
+      goto fail;
+    }
+  }
+
   return mem;
 
   /* ERRORS */
diff --git a/sys/kms/gstkmsallocator.h b/sys/kms/gstkmsallocator.h
index 76d4312..d1282b7 100644
--- a/sys/kms/gstkmsallocator.h
+++ b/sys/kms/gstkmsallocator.h
@@ -1,10 +1,12 @@
 /* GStreamer
  *
  * Copyright (C) 2016 Igalia
+ * Copyright (C) Microchip Technology Inc.
  *
  * Authors:
  *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
  *  Javier Martin <javiermartin@by.com.es>
+ *  Sandeep Sheriker M <sandeepsheriker.mallikarjun@microchip.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -28,6 +30,7 @@
 
 #include <gst/gst.h>
 #include <gst/video/video.h>
+#include  "gstkmssink.h"
 
 G_BEGIN_DECLS
 
@@ -63,6 +66,7 @@ struct _GstKMSMemory
 struct _GstKMSAllocator
 {
   GstAllocator parent;
+  GstKMSSink *kmssink;
   GstKMSAllocatorPrivate *priv;
 };
 
@@ -75,7 +79,7 @@ GType gst_kms_allocator_get_type (void) G_GNUC_CONST;
 gboolean gst_is_kms_memory (GstMemory *mem);
 guint32 gst_kms_memory_get_fb_id (GstMemory *mem);
 
-GstAllocator* gst_kms_allocator_new (gint fd);
+GstAllocator *gst_kms_allocator_new (GstKMSSink * self);
 
 GstMemory*    gst_kms_allocator_bo_alloc (GstAllocator *allocator,
 					  GstVideoInfo *vinfo);
diff --git a/sys/kms/gstkmssink.c b/sys/kms/gstkmssink.c
index d19e19e..67661b9 100644
--- a/sys/kms/gstkmssink.c
+++ b/sys/kms/gstkmssink.c
@@ -1,10 +1,13 @@
 /* GStreamer
  *
  * Copyright (C) 2016 Igalia
+ * Copyright (C) Microchip Technology Inc.
  *
  * Authors:
  *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
  *  Javier Martin <javiermartin@by.com.es>
+ *  Sandeep Sheriker M
+ *	<sandeepsheriker.mallikarjun@microchip.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -23,6 +26,12 @@
  *
  */
 
+/*
+ * kmsink is customized for Microchip(Atmel AT91) SAMA5D4 to
+ * implement as a DRM client using GEM handle and render video
+ * frames directly on planes of a DRM/KMS device using zerocopy.
+ */
+
 /**
  * SECTION:element-kmssink
  * @title: kmssink
@@ -76,6 +85,7 @@ enum
   PROP_CONNECTOR_ID,
   PROP_PLANE_ID,
   PROP_FORCE_MODESETTING,
+  PROP_GEM_NAME,
   PROP_N
 };
 
@@ -496,6 +506,7 @@ gst_kms_sink_start (GstBaseSink * bsink)
   drmModePlane *plane;
   gboolean universal_planes;
   gboolean ret;
+  struct drm_gem_open gemobj;
 
   self = GST_KMS_SINK (bsink);
   universal_planes = FALSE;
@@ -517,8 +528,26 @@ gst_kms_sink_start (GstBaseSink * bsink)
   if (!get_drm_caps (self))
     goto bail;
 
-  self->can_scale = TRUE;
 
+  GST_INFO_OBJECT (self, "GEM Name: %d\n", self->gemname);
+  if (self->gemname > 0) {
+
+    memset (&gemobj, 0, sizeof (gemobj));
+    gemobj.name = self->gemname;
+    ret = drmIoctl (self->fd, DRM_IOCTL_GEM_OPEN, &gemobj);
+    if (ret < 0) {
+      GST_ERROR_OBJECT (self, "could not flink %d", ret);
+      goto bail;
+    }
+    self->gemhandle = gemobj.handle;
+    self->gemsize = gemobj.size;
+    GST_INFO_OBJECT (self, "GEM handle: %d\n", gemobj.handle);
+    GST_INFO_OBJECT (self, "GEM Size: %lld\n", gemobj.size);
+    self->Ismaster = FALSE;
+    self->can_scale = FALSE;
+  } else {
+
+  self->can_scale = TRUE;
   res = drmModeGetResources (self->fd);
   if (!res)
     goto resources_failed;
@@ -576,6 +605,12 @@ retry_find_plane:
   GST_INFO_OBJECT (self, "display size: pixels = %dx%d / millimeters = %dx%d",
       self->hdisplay, self->vdisplay, self->mm_width, self->mm_height);
 
+    self->mm_width = conn->mmWidth;
+    self->mm_height = conn->mmHeight;
+
+    GST_INFO_OBJECT (self, "display size: pixels = %dx%d / millimeters = %dx%d",
+        self->hdisplay, self->vdisplay, self->mm_width, self->mm_height);
+  }
   self->pollfd.fd = self->fd;
   gst_poll_add_fd (self->poll, &self->pollfd);
   gst_poll_fd_ctl_read (self->poll, &self->pollfd, TRUE);
@@ -724,7 +759,7 @@ ensure_kms_allocator (GstKMSSink * self)
 {
   if (self->allocator)
     return;
-  self->allocator = gst_kms_allocator_new (self->fd);
+  self->allocator = gst_kms_allocator_new (self);
 }
 
 static GstBufferPool *
@@ -1143,6 +1178,8 @@ gst_kms_sink_get_input_buffer (GstKMSSink * self, GstBuffer * inbuf)
   GstVideoFrame inframe, outframe;
   gboolean success;
 
+  GST_TRACE_OBJECT (self, "In %s : doing frame copy \n", __func__);
+
   mem = gst_buffer_peek_memory (inbuf, 0);
   if (!mem)
     return NULL;
@@ -1234,6 +1271,8 @@ gst_kms_sink_show_frame (GstVideoSink * vsink, GstBuffer * buf)
   buffer = gst_kms_sink_get_input_buffer (self, buf);
   if (!buffer)
     return GST_FLOW_ERROR;
+
+  if (self->Ismaster) {
   fb_id = gst_kms_memory_get_fb_id (gst_buffer_peek_memory (buffer, 0));
   if (fb_id == 0)
     goto buffer_invalid;
@@ -1244,6 +1283,7 @@ gst_kms_sink_show_frame (GstVideoSink * vsink, GstBuffer * buf)
     self->buffer_id = fb_id;
     goto sync_frame;
   }
+  }
 
   if ((crop = gst_buffer_get_video_crop_meta (buffer))) {
     GstVideoInfo vinfo = self->vinfo;
@@ -1278,6 +1318,7 @@ retry_set_plane:
       "drmModeSetPlane at (%i,%i) %ix%i sourcing at (%i,%i) %ix%i",
       result.x, result.y, result.w, result.h, src.x, src.y, src.w, src.h);
 
+  if (self->Ismaster) {
   ret = drmModeSetPlane (self->fd, self->plane_id, self->crtc_id, fb_id, 0,
       result.x, result.y, result.w, result.h,
       /* source/cropping coordinates are given in Q16 */
@@ -1289,6 +1330,7 @@ retry_set_plane:
     }
     goto set_plane_failed;
   }
+  }
 
 sync_frame:
   /* Wait for the previous frame to complete redraw */
@@ -1349,6 +1391,9 @@ gst_kms_sink_set_property (GObject * object, guint prop_id,
     case PROP_FORCE_MODESETTING:
       sink->modesetting_enabled = g_value_get_boolean (value);
       break;
+    case PROP_GEM_NAME:
+      sink->gemname = g_value_get_int (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1376,6 +1421,9 @@ gst_kms_sink_get_property (GObject * object, guint prop_id,
     case PROP_FORCE_MODESETTING:
       g_value_set_boolean (value, sink->modesetting_enabled);
       break;
+    case PROP_GEM_NAME:
+      g_value_set_int (value, sink->gemname);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1400,6 +1448,9 @@ gst_kms_sink_init (GstKMSSink * sink)
   sink->fd = -1;
   sink->conn_id = -1;
   sink->plane_id = -1;
+  sink->gemhandle = 0;
+  sink->gemsize = 0;
+  sink->Ismaster = TRUE;
   gst_poll_fd_init (&sink->pollfd);
   sink->poll = gst_poll_new (TRUE);
   gst_video_info_init (&sink->vinfo);
@@ -1484,6 +1535,11 @@ gst_kms_sink_class_init (GstKMSSinkClass * klass)
       "When enabled, the sink try to configure the display mode", FALSE,
       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
 
+  g_properties[PROP_GEM_NAME] = g_param_spec_int ("gem-name", "gem-name",
+      "when gem name is set, kmssink will function as drm client"
+      "and communicate with drm master using gem name", -1, G_MAXINT32, -1,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
   g_object_class_install_properties (gobject_class, PROP_N, g_properties);
 }
 
diff --git a/sys/kms/gstkmssink.h b/sys/kms/gstkmssink.h
index 214f3ad..9757cb4 100644
--- a/sys/kms/gstkmssink.h
+++ b/sys/kms/gstkmssink.h
@@ -1,10 +1,12 @@
 /* GStreamer
  *
  * Copyright (C) 2016 Igalia
+ * Copyright (C) Microchip Technology Inc.
  *
  * Authors:
  *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
  *  Javier Martin <javiermartin@by.com.es>
+ *  Sandeep Sheriker M <sandeepsheriker.mallikarjun@microchip.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -78,6 +80,10 @@ struct _GstKMSSink {
 
   GstPoll *poll;
   GstPollFD pollfd;
+
+  gint32 gemname;
+  guint32 gemsize, gemhandle;
+  gboolean Ismaster;
 };
 
 struct _GstKMSSinkClass {
-- 
2.7.4

